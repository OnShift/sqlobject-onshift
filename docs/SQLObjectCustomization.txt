Customizing the Objects
-----------------------

While we haven't done so in the examples, you can include your own
methods in the class definition.  Writing you own methods should be
obvious enough (just do so like in any other class), but there are
some other details to be aware of.

Initializing the Objects
~~~~~~~~~~~~~~~~~~~~~~~~

There are two ways SQLObject instances can come into existance: they
can be fetched from the database, or they can be inserted into the
database.  In both cases a new Python object is created.  This makes
the place of `__init__` a little confusing.

In general, you should not touch `__init__`.  Instead use the `_init`
method, which is called after an object is fetched or inserted.  This
method has the signature ``_init(self, id, connection=None,
selectResults=None)``, though you may just want to use ``_init(self,
*args, **kw)``.  **Note:** don't forget to call
``SQLObject._init(self, *args, **kw)`` if you override the method!

Adding Magic Attributes (properties)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use all the normal techniques for defining methods in this
new-style class, including `classmethod`, `staticmethod`, and
`property`, but you can also use a shortcut.  If you have a method
that's name starts with ``_set_``, ``_get_``, ``_del_``, or ``_doc_``,
it will be used to create a property.  So, for instance, say you have
images stored under the ID of the person in the ``/var/people/images``
directory:

.. raw:: html
   :file: ../examples/snippets/person_magicmethod.html

Later, you can use the ``.image`` property just like an attribute, and
the changes will be reflected in the filesystem by calling these
methods.  This is a good technique for information that is better to
keep in files as opposed to the database (such as large, opaque data
like images).

You can also pass an ``image`` keyword argument to the `new` class
method or the `set` method, like ``Person.new(..., image=imageText)``.

All of the methods (``_get_``, ``_set_``, etc) are optional -- you can
use any one of them without using the others (except ``_doc_``, since
having a doc string that doesn't document anything would be silly).
So you could define just a ``_get_attr`` method so that ``attr`` was
read-only.

Overriding Column Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It's a little more complicated if you want to override the behavior of
an database column attribute.  For instance, imagine there's special
code you want to run whenever someone's name changes -- you could make
a subclass, and then use ``Person.__setattr__(self, 'lastName',
value)`` to actually do the deed, but that's obviously very awkward --
you have to create subclasses without a real inheritance relationship,
and the whole thing feels architecturally fragile.  SQLObject creates
methods like ``_set_lastName`` for each of your columns, but again you
can't use this, since there's no superclass to reference (and you
can't write ``SQLObject._set_lastName(...)``, because the SQLObject
class doesn't know about your class's columns).  You want to override
that ``_set_lastName`` method yourself.

To deal with this, SQLObject creates two methods for each getter and
setter, for example: ``_set_lastName`` and ``_SO_set_lastName``.  So
to intercept all changes to ``lastName``:

.. raw:: html
   :file: ../examples/snippets/person_magicoverride.html

Or perhaps you want to constrain a phone numbers to be actual
digits, and of proper length, and make the formatting nice:

.. raw:: html
   :file: ../examples/snippets/phonenumber_magicoverride.html

.. note::

   You should be a little cautious when modifying data that gets set
   in an attribute.  Generally someone using your class will expect
   that the value they set the attribute to will be the same value
   they get back.  In this example we removed some of the characters
   before putting it in the database, and reformatted it on the way
   out.  One advantage of methods (as opposed to attribute access) is
   that the programmer is more likely to expect this disconnect.
