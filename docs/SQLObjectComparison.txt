Compared To Other Database Wrappers
===================================

There are several object-relational mappers (ORM) for Python.  I
honestly can't comment deeply on the quality of those packages, but
I'll try to place SQLObject in perspective.

SQLObject uses new-style classes extensively.  The resultant objects
have a new-style feel as a result -- setting attributes has side
effects (it changes the database), and defining classes has side
effects (through the use of metaclasses).  Attributes are generally
exposed, not marked private, knowing that they can be made dynamic
or write-only later.

SQLObject creates objects that feel similar to normal Python objects
(with the semantics of new-style classes).  An attribute attached to a
column doesn't look different than an attribute that's attached to a
file, or an attribute that is calculated.  It is a specific goal that
you be able to change the database without changing the interface,
including changing the scope of the database, making it more or less
prominent as a storage mechanism.

This is in contrast to some ORMs that provide a dictionary-like
interface to the database (for example, PyDO_).  The dictionary
interface distinguishes the row from a normal Python object.  I also
don't care for the use of strings where an attribute seems more
natural -- columns are limited in number and predefined, just like
attributes.  (Note: newer version of PyDO apparently allow attribute
access as well)

.. _PyDO: http://skunkweb.sourceforge.net/pydo.html

SQLObject is, to my knowledge, unique in using metaclasses to
facilitate this seemless integration.  Some other ORMs use code
generation to create an interface, expressing the schema in a CSV or
XML file (for example, MiddleKit, part of Webware_).  By using
metaclasses you are able to comfortably define your schema in the
Python source code.  No code generation, no weird tools, no
compilation step.

.. _Webware: http://webware.sourceforge.net

SQLObject provides a strong database abstraction, allowing
cross-database compatibility (so long as you don't sidestep
SQLObject).

SQLObject has joins, one-to-many, and many-to-many, something which
many ORMs do not have.  The join system is also intended to be
extensible.

You can map between database names and Python attribute and class
names; often these two won't match, or the database style would be
inappropriate for a Python attribute.  This way your database schema
does not have to be designed with SQLObject in mind, and the resulting
classes do not have to inherit the database's naming schemes.
