Automatic Schema Generation
---------------------------

All the connections support creating and droping tables based on the
class definition.  First you have to prepare your class definition,
which means including type information in your columns.

Columns Types
~~~~~~~~~~~~~

A column type is indicated by using a subclass of `Col`:

`StringCol`:
    StringCol represents ``CHAR``, ``VARCHAR``, and ``TEXT``.  The
    `length` keyword argument indicates the ``CHAR`` or ``VARCHAR``
    length -- if not given, then ``TEXT`` is assumed.  If you use
    ``varchar=False`` then ``CHAR`` will be used, otherwise 
    ``VARCHAR`` is the default.
`IntCol`:
    The ``INT`` type.
`FloatCol`:
    The ``FLOAT`` type.
`DecimalCol`:
    The ``DECIMAL`` SQL type, i.e., base 10 number.  The keyword 
    arguments `size` and `precision` indicate the scope.  So
    ``DecimalCol(size=5, precision=2)`` is a number like ###.##,
    i.e., 5 digits, two of them past the decimal point.
`CurrencyCol`:
    Like ``DecimalCol(size=10, precision=2)``.
`EnumCol`:
    A MySQL ``ENUM``, i.e., one of a finite number of strings.
    For other databases this will be a ``VARCHAR``.
`DateTimeCol`:
    A moment in time.  ``TIMESTAMP`` in Postgres, and ``DATETIME``
    in MySQL.  Note the names of these columns match the *Python*
    type names, not the SQL names.
`ForeignKey`:
    This is a reference to another table.  You typically need to
    only give the name of the foreign class that is referenced.
    `ForeignKey` implies an ``INT`` column.

Indexes
~~~~~~~

You can also define indexes for your tables, which is only meaningful
when creating your tables through SQLObject (SQLObject relies on the
database to implement the indexes).  You do this again with attribute
assignment, like::

    firstLastIndex = DatabaseIndex('firstName', 'lastName')

This creates an index on two columns, useful if you are selecting a
particular name.  Of course, you can give a single column, and you can
give the column object (``firstName``) instead of the string name.
Note that if you use ``unique`` or ``alternateID`` (which implies
``unique``) the database may make an index for you, and primary keys
are always indexed.

If you give the keyword argument ``unique`` to `DatabaseIndex` you'll
create a unique index -- the combination of columns must be unique.

You can also use dictionaries in place of the column names, to add
extra options.  E.g.::

    lastNameIndex = DatabaseIndex({'expression': 'lower(last_name)'})

In that case, the index will be on the lower-case version of the
column.  It seems that only PostgreSQL supports this.  You can also
do::

    lastNameIndex = DatabaseIndex({'column': lastName, 'length': 10})

Which asks the database to only pay attention to the first ten
characters.  Only MySQL supports this, but it is ignored in other
databases.

Creating and Dropping Tables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To create a table call `createTable`.  It takes two arguments:

`ifNotExists`: 
    If the table already exists, then don't try to create it.  Default
    False.
`createJoinTables`: 
    If you used `Many-to-Many relationships`_, then the intermediate tables
    will be created (but only for one of the two involved classes).
    Default True.

`dropTable` takes arguments `ifExists` and `dropJoinTables`,
self-explanatory.
