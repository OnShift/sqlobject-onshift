Many-to-Many Relationships
--------------------------

For this example we will have user and role objects.  The two have a
many-to-many relationship, which is represented with the
`RelatedJoin`.

.. raw:: html
   :file: ../examples/snippets/userrole-classes.html

And usage:

.. raw:: html
   :file: ../examples/snippets/userrole-use.html

In the process an intermediate table is created, ``role_user``, which
references both of the other classes.  This table is never exposed as
a class, and its rows do not have equivalent Python objects -- this
hides some of the nuisance of a many-to-many relationship.

You may notice that the columns have the extra keyword argument
`alternateID`.  If True, this means that the column uniquely
identifies rows -- like a username uniquely identifies a user.  This
identifier is in addition to the primary key (``id``), which is always
present.

.. note::
   SQLObject has a strong requirement that the primary key be unique
   and *immutable*.  You cannot change the primary key through
   SQLObject, and if you change it through another mechanism you can
   cause inconsistency in any running SQLObject program (and in your
   data).  For this reason meaningless integer IDs are encouraged --
   something like a username that could change in the future may
   uniquely identify a row, but it may be changed in the future.  So
   long as it is not used to reference the row internally, it is also
   *safe* to change it in the future.

A alternateID column creates a class method, like ``byUsername`` for a
column named ``username`` (or you can use the `alternateMethodName`
keyword argument to override this).  Its use:

.. raw:: html
   :file: ../examples/snippets/userrole-use-alternate.html
