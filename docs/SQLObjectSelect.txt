Selecting Multiple Objects
--------------------------

While the full power of all the kinds of joins you can do with a
database are not revealed in SQLObject, a simple ``SELECT`` is
available.

``select`` is a class method, and you call it like (with the SQL
that's generated):

.. raw:: html
   :file: ../examples/snippets/person-select1.html

This example returns everyone with the first name John.  An expression
could be more complicated as well, like:

.. raw:: html
   :file: ../examples/snippets/person-select2.html

You'll note that classes have an attribute ``q``, which gives access
to special objects for constructing query clauses.  All attributes
under ``q`` refer to column names and if you construct logical
statements with these it'll give you the SQL for that statement.  You
can also work like this:

.. raw:: html
   :file: ../examples/snippets/person-select3.html

You may wish to use `MyClass.sqlrepr` to quote any values you use if
you create SQL manually (quoting is automatic if you use ``q``).
Tables given in `clauseTables` will be added to the ``FROM`` portion
(again, they are automatically picked up when using ``q``).  The table
you're selecting is always assumed to be included, of course.

.. _orderBy:

You can use the keyword arguments `orderBy` to create ``ORDER BY`` in
the select statements: `orderBy` takes a string, which should be the
*database* name of the column, or a column in the form
``Person.q.firstName``.  You can use ``"-colname"`` to specify
descending order, or call ``MyClass.select().reversed()``.

You can use the special class variable `_defaultOrder` to give a
default ordering for all selects.  To get an unordered result when
`_defaultOrder` is used, use ``orderBy=None``.

Select results are generators, which are lazily evaluated.  So the SQL
is only executed when you iterate over the select results, or if you
use ``list()`` to force the result to be executed.  When you iterate
over the select results, rows are fetched one at a time.  This way you
can iterate over large results without keeping the entire result set
in memory.  You can also do things like ``.reversed()`` without
fetching and reversing the entire result -- instead, SQLObject can
change the SQL that is sent so you get equivalent results.

You can also slice select results.  The results are used in the SQL
query, so ``peeps[:10]`` will result in ``LIMIT 10`` being added to
the end of the SQL query.  If the slice cannot be performed in the SQL
(e.g., peeps[:-10]), then the select is executed, and the slice is
performed on the list of results.  This will only happen when you use
negative indexes.

In certain cases, you may get a select result with an object in it
more than once, e.g., in some joins.  If you don't want this, you can
add the keyword argument ``MyClass.select(..., distinct=True)``.

You can get the length of the result without fetching all the results
by calling ``count`` on the result object, like
``MyClass.select().count()``.  A ``COUNT(*)`` query is used -- the
actual objects are not fetched from the database.  Together with
slicing, this makes batched queries easy to write:

.. raw:: html
   :file: ../examples/snippets/slicing-batch.html

.. note:: 

   There are several factors when considering the efficiency of this
   kind of batching, and it depends very much how the batching is
   being used.  Consider a web application where you are showing an
   average of 100 results, 10 at a time, and the results are ordered
   by the date they were added to the database.  While slicing will
   keep the database from returning all the results (and so save some
   communication time), the database will still have to scan through
   the entire result set to sort the items (so it knows which the
   first ten are), and depending on your query may need to scan
   through the entire table (depending on your use of indexes).
   Indexes are probably the most important way to improve importance
   in a case like this, and you may find caching to be more effective
   than slicing.

   In this case, caching would mean retrieving the *complete* results.
   You can use ``list(MyClass.select(...))`` to do this.  You can save
   these results for some limited period of time, as the user looks
   through the results page by page.  This means the first page in a
   search result will be slightly more expensive, but all later pages
   will be very cheap.

For more information on the where clause in the queries, see the
`SQLBuilder documentation`_.

.. _`SQLBuilder documentation`: SQLBuilder.html

Select-By Method
~~~~~~~~~~~~~~~~

An alternative to ``.select`` is ``.selectBy``.  It works like:

.. raw:: html
   :file: ../examples/snippets/person-select-by.html

Each keyword argument is a column, and all the keyword arguments
are ANDed together.  The return value is a `SelectResult`, so you
can slice it, count it, order it, etc.
